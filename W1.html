
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Word Miner</title>
<style>
body {
font-family: sans-serif;
background-color: #f5f5f5;
display: flex;
flex-direction: column;
align-items: center;
margin: 0;
}

h1 {
margin: 20px 0 10px;
font-size: 32px;
}

p.rule {
margin: 0 0 15px;
font-size: 16px;
color: #555;
}

.container {
display: flex;
align-items: flex-start;
gap: 20px;
margin-bottom: 20px;
}

#npcScore, #userScore {
width: 140px;
min-height: 300px;
padding: 10px;
font-size: 18px;
font-weight: bold;
border: 2px solid #333;
box-sizing: border-box;
}

#npcScore {
background-color: #f8c6c6;
}

#userScore {
background-color: #c6e2ff;
}

#game {
display: grid;
grid-template-columns: repeat(6, 50px);
grid-gap: 5px;
padding: 10px;
border: 2px solid #333;
background-color: #eee;
}

.cell {
width: 50px;
height: 50px;
background-color: #ddd;
display: flex;
justify-content: center;
align-items: center;
font-size: 18px;
cursor: pointer;
user-select: none;
border: 1px solid #999;
}

.revealed {
background-color: #fff;
}

.word-owned-user {
background-color: #c6e2ff;
}

.word-owned-npc {
background-color: #f8c6c6;
}

#retryBtn {
font-size: 18px;
padding: 14px 32px;
margin: 20px;
cursor: pointer;
}
</style>
</head>
<body>
<h1>Word Miner</h1>
<p class="rule"> click tiles, find words, win! </p>

<div class="container">
<div id="npcScore">conputer:<br></div>
<div id="game"></div>
<div id="userScore">You:<br></div>
</div>
<button id="retryBtn">Retry</button>

<script>
const wordList = [
'pear', 'lion', 'rose', 'book', 'frog', 'cake', 'tree', 'moon', 'bird', 'shoe', 'milk', 'fish', 'lamp', 'sand', 'wind', 'snow', 'rain', 'star', 'leaf', 'desk', 'cake', 'frog', 'milk', 'fish', 'ring', 'cup', 'fork', 'dish', 'salt', 'time', 'home', 'fire', 'ball', 'coin', 'wall', 'love', 'jump', 'dust', 'food', 'rain', 'goat', 'deer', 'leaf', 'pear', 'corn', 'worm', 'crow', 'rock', 'doll', 'flag', 'bear', 'gift', 'hill', 'rice', 'rope', 'bone', 'game', 'lamp', 'lock', 'wine', 'bell', 'horn', 'mask', 'tape', 'dish', 'salt', 'plan', 'road', 'clay', 'tool', 'hole', 'cave', 'bush', 'bomb', 'king', 'cook', 'barn', 'path', 'wolf', 'bag', 'drum', 'seed', 'vase', 'cold', 'heat', 'tent', 'gold', 'iron', 'wood', 'sink', 'fork', 'soap', 'pond', 'duck', 'bean', 'flop', 'joke', 'zero', 'fast', 'slow', 'deep', 'soft', 'hard', 'dark', 'open', 'lost', 'blue', 'cool', 'run', 'sing', 'hug', 'kiss', 'sun', 'walk', 'math', 'java', 'chat', 'code', 'test', 'hope', 'feel', 'eyes', 'face', 'lamb', 'cow', 'pig', 'dog', 'cat', 'ant', 'bee', 'fly', 'zoom', 'grid', 'line', 'edge', 'mark', 'void', 'soda', 'wire', 'keys', 'knob', 'door', 'tone', 'song', 'tune', 'whim', 'card', 'nine', 'four', 'root', 'stem', 'bud', 'melt', 'jazz', 'cube', 'zone', 'drop', 'dive', 'soar', 'rise', 'fall', 'climb', 'slip', 'roll', 'tilt', 'turn', 'grab', 'hold', 'push', 'pull', 'spin', 'bend', 'laugh', 'smile', 'cry', 'yell', 'blur', 'glow', 'fade', 'rust', 'dust', 'mist', 'haze', 'rays', 'wave', 'bark', 'meow', 'neck', 'arm', 'back', 'knee', 'toe', 'lips', 'hair', 'skin', 'heat', 'iced', 'mud', 'rock', 'nest', 'eggs', 'twig', 'petal', 'grass', 'sheep', 'horse', 'mule', 'calf', 'hen', 'owl', 'swan', 'crab', 'seal', 'whale', 'squid', 'tuna', 'perl', 'corn', 'bean', 'rice', 'cake', 'bread', 'soup', 'meat', 'egg', 'tofu', 'chop', 'fry', 'boil', 'bake', 'juice', 'tea', 'wine', 'beer', 'salad', 'sugar', 'honey', 'jam', 'oven', 'stir', 'pan', 'dish', 'spoo', 'mug', 'cup', 'glas', 'tray', 'bowl', 'plat', 'year', 'week', 'day', 'hour', 'min', 'clock', 'dial', 'tick', 'dawn', 'noon', 'dusk', 'sky', 'gray', 'pink', 'lime', 'cyan', 'mint', 'navy', 'jade', 'ruby', 'silv', 'metl', 'tin', 'zinc', 'lead', 'coal', 'lava', 'burnt', 'drip', 'pour', 'flow', 'wash', 'swim', 'surf', 'tide', 'blow', 'gust', 'rush', 'stir', 'calm', 'still', 'bush', 'vine', 'weed', 'pine', 'oak', 'palm', 'bark', 'beak', 'wing', 'fang', 'claw', 'toes', 'paws', 'tail', 'hide', 'bone', 'vein', 'cell', 'gene', 'data', 'chip', 'byte', 'bits', 'file', 'text', 'font', 'page', 'read', 'type', 'send', 'copy', 'save', 'close', 'edit', 'draw', 'click', 'link', 'scan', 'print', 'email', 'play', 'win', 'lose', 'fail', 'pass', 'goal', 'plan', 'task', 'work', 'rest', 'move', 'stop', 'start', 'lima', 'rome', 'seul', 'cairo', 'athens', 'paris', 'osaka', 'amman', 'lima', 'tokyo', 'rio', 'miami', 'oslo', 'rome', 'sydney', 'london', 'tokyo', 'osaka', 'seoul', 'paris', 'bern', 'miami', 'rio', 'saigon', 'rio', 'amman', 'tunis', 'rio', 'tokyo', 'hanoi', 'lisbon',
];
const gridSize = 6;
const totalCells = gridSize * gridSize;
let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words;
let resultShown = false;

const gameEl = document.getElementById('game');
const userScoreEl = document.getElementById('userScore');
const npcScoreEl = document.getElementById('npcScore');
const retryBtn = document.getElementById('retryBtn');

function shuffle(arr) {
for (let i = arr.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[arr[i], arr[j]] = [arr[j], arr[i]];
}
}

function getRandomWords(n) {
const temp = [...wordList];
shuffle(temp);
return temp.slice(0, n);
}

function getRandomDirection() {
const dirs = [
{ x: 1, y: 0 },
{ x: 0, y: 1 },
{ x: 1, y: 1 },
];
return dirs[Math.floor(Math.random() * dirs.length)];
}

function canPlaceWord(word, x, y, dx, dy) {
for (let i = 0; i < word.length; i++) {
let nx = x + dx * i;
let ny = y + dy * i;
if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
let index = ny * gridSize + nx;
if (board[index] && board[index] !== word[i]) return false;
}
return true;
}

function placeWord(word) {
for (let attempt = 0; attempt < 100; attempt++) {
let dir = getRandomDirection();
let x = Math.floor(Math.random() * gridSize);
let y = Math.floor(Math.random() * gridSize);
if (canPlaceWord(word, x, y, dir.x, dir.y)) {
let positions = [];
for (let i = 0; i < word.length; i++) {
let nx = x + dir.x * i;
let ny = y + dir.y * i;
let idx = ny * gridSize + nx;
board[idx] = word[i];
positions.push(idx);
}
wordMap[word] = positions;
return true;
}
}
return false;
}



function fillEmptyCells() {
const filler = ''.split('');
let iFiller = 0;
for (let i = 0; i < totalCells; i++) {
if (!board[i]) board[i] = filler[iFiller++ % filler.length];
}
}

function updateScore() {
userScoreEl.innerHTML = "You:<br>" + foundBy.user.join("<br>");
npcScoreEl.innerHTML = "computer:<br>" + foundBy.npc.join("<br>");
}

function reveal(index) {
if (revealed[index]) return;
revealed[index] = true;
const cell = gameEl.children[index];
cell.classList.add('revealed');
cell.textContent = board[index];
}

function checkWords() {
for (let word of words) {
if (foundWords.has(word)) continue;
const positions = wordMap[word];
if (positions.every(i => revealed[i])) {
foundWords.add(word);
let owner = currentPlayer === 'user' ? 'user' : 'npc';
foundBy[owner].push(word);
for (let i of positions) {
gameEl.children[i].classList.add(owner === 'user' ? 'word-owned-user' : 'word-owned-npc');
}
updateScore();
}
}

if (foundWords.size === words.length && !resultShown) {
resultShown = true;
let userCount = foundBy.user.length;
let npcCount = foundBy.npc.length;
if (userCount > npcCount) {
userScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>WIN</span>";
npcScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>LOSE</span>";
} else if (npcCount > userCount) {
npcScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>WIN</span>";
userScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>LOSE</span>";
} else {
userScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>DRAW</span>";
npcScoreEl.innerHTML += "<br><br><span style='font-size:24px;'>DRAW</span>";
}
}
}

function switchTurn() {
currentPlayer = currentPlayer === 'user' ? 'npc' : 'user';
if (currentPlayer === 'npc') {
setTimeout(npcTurn, 800);
}
}

function npcTurn() {
let options = revealed.map((rev, idx) => !rev ? idx : null).filter(idx => idx !== null);
if (options.length === 0) return;
let choice = options[Math.floor(Math.random() * options.length)];
handleClick(choice);
}


function handleClick(index) {
if (revealed[index] || resultShown) return; // 게임이 끝났으면 클릭 무시
reveal(index);
checkWords();
switchTurn();
}



function init() {
board = Array(totalCells).fill(null);
revealed = Array(totalCells).fill(false);
wordMap = {};
foundWords = new Set();
foundBy = { user: [], npc: [] };
currentPlayer = 'user';
words = getRandomWords(4);
resultShown = false;

for (let word of words) {
placeWord(word);
}
fillEmptyCells();
updateScore();

gameEl.innerHTML = '';
for (let i = 0; i < totalCells; i++) {
const cell = document.createElement('div');
cell.className = 'cell';
cell.addEventListener('click', () => {
if (currentPlayer === 'user') {
handleClick(i);
}
});
gameEl.appendChild(cell);
}
}

retryBtn.addEventListener('click', init);
init();
</script>

<div id="credits" style="margin-top: 50px; font-size: 1em; color: gray; text-align: center; line-height: 1.6;">
<p>Idea & Planning by <strong>Soosoohan</strong></p>
<p>Code developed with help from <strong>OpenAI</strong></p>
<p>Special Thanks to<br>Nature Lee, Juju, Coxon, Ung, Mong and Zziny</p>
<p>Thanks for playing!</p>
</div>
</body>
</html>
